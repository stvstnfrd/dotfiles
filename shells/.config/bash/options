#!/bin/bash

# The following comments were autogenerated from the bash man page.
# They describe the effects of enabling the specified option:
#  shopt -s optname

# a command name that is the name of a directory is executed as if it
# were the argument to the cd command.  This option is only used by
# interactive shells.
shopt -u autocd 2>/dev/null || true

# an argument to the cd builtin command that is not a directory is
# assumed to be the name of a variable whose value is the directory to
# change to.
shopt -u cdable_vars 2>/dev/null || true

# minor errors in the spelling of a directory component in a cd command
# will be corrected.  The errors checked for are transposed characters,
# a missing character, and one character too many.  If a correction is
# found, the corrected file name is printed, and the command proceeds.
# This option is only used by interactive shells.
shopt -u cdspell 2>/dev/null || true

# checks that a command found in the hash table exists before trying to
# execute it.  If a hashed command no longer exists, a normal path
# search is performed.
shopt -u checkhash 2>/dev/null || true

# lists the status of any stopped and running jobs before exiting an
# interactive shell.  If any jobs are running, this causes the exit to
# be deferred until a second exit is attempted without an intervening
# command (see JOB CONTROL above).  The shell always postpones exiting
# if any jobs are stopped.
shopt -u checkjobs 2>/dev/null || true

# checks the window size after each command and, if necessary, updates
# the values of LINES and COLUMNS.
shopt -u checkwinsize 2>/dev/null || true

# attempts to save all lines of a multiple-line command in the same
# history entry.  This allows easy re-editing of multi-line commands.
shopt -u cmdhist 2>/dev/null || true

# changes its behavior to that of version 3.1 with respect to quoted
# arguments to the [[ conditional command's =~ operator.
shopt -u compat31 2>/dev/null || true

# changes its behavior to that of version 3.2 with respect to
# locale-specific string comparison when using the [[ conditional
# command's < and > operators.  Bash versions prior to bash-4.1 use
# ASCII collation and strcmp(3); bash-4.1 and later use the current
# locale's collation sequence and strcoll(3).
shopt -u compat32 2>/dev/null || true

# changes its behavior to that of version 4.0 with respect to
# locale-specific string comparison when using the [[ conditional
# command's < and > operators (see previous item) and the effect of
# interrupting a command list.
shopt -u compat40 2>/dev/null || true

# when in posix mode, treats a single quote in a double-quoted
# parameter expansion as a special character.  The single quotes must
# match (an even number) and the characters between the single quotes
# are considered quoted.  This is the behavior of posix mode through
# version 4.1.  The default bash behavior remains as in previous
# versions.
shopt -u compat41 2>/dev/null || true

# replaces directory names with the results of word expansion when
# performing filename completion.  This changes the contents of the
# readline editing buffer.  If not set, bash attempts to preserve what
# the user typed.
shopt -u direxpand 2>/dev/null || true

# attempts spelling correction on directory names during word
# completion if the directory name initially supplied does not exist.
shopt -u dirspell 2>/dev/null || true

# includes filenames beginning with a `.' in the results of pathname
# expansion.
shopt -u dotglob 2>/dev/null || true

# a non-interactive shell will not exit if it cannot execute the file
# specified as an argument to the exec builtin command.  An interactive
# shell does not exit if exec fails.
shopt -u execfail 2>/dev/null || true

# aliases are expanded as described above under ALIASES.  This option
# is enabled by default for interactive shells.
shopt -s expand_aliases 2>/dev/null || true

# behavior intended for use by debuggers is enabled:
# 1.     The -F option to the declare builtin displays the source file
# name and line number corresponding to each function name supplied as
# an argument.
# 2.     If the command run by the DEBUG trap returns a non-zero value,
# the next command is skipped and not executed.
# 3.     If the command run by the DEBUG trap returns a value of 2, and
# the shell is executing in a subroutine (a shell function or a shell
# script executed by the . or source builtins), a call to return is
# simulated.
# 4.     BASH_ARGC and BASH_ARGV are updated as described in their
# descriptions above.
# 5.     Function tracing is enabled:  command substitution, shell
# functions, and subshells invoked with ( command ) inherit the DEBUG
# and RETURN traps.
# 6.     Error tracing is enabled:  command substitution, shell
# functions, and subshells invoked with ( command ) inherit the ERR
# trap.
shopt -u extdebug 2>/dev/null || true

# the extended pattern matching features described above under Pathname
# Expansion are enabled.
shopt -s extglob 2>/dev/null || true

# $'string' and $"string" quoting is performed within ${parameter}
# expansions enclosed in double quotes.  This option is enabled by
# default.
shopt -s extquote 2>/dev/null || true

# patterns which fail to match filenames during pathname expansion
# result in an expansion error.
shopt -u failglob 2>/dev/null || true

# the suffixes specified by the FIGNORE shell variable cause words to
# be ignored when performing word completion even if the ignored words
# are the only possible completions.  See SHELL VARIABLES above for a
# description of FIGNORE.  This option is enabled by default.
shopt -s force_fignore 2>/dev/null || true

# the pattern ** used in a pathname expansion context will match all
# files and zero or more directories and subdirectories.  If the
# pattern is followed by a /, only directories and subdirectories match.
shopt -u globstar 2>/dev/null || true

# shell error messages are written in the standard GNU error message
# format.
shopt -u gnu_errfmt 2>/dev/null || true

# the history list is appended to the file named by the value of the
# HISTFILE variable when the shell exits, rather than overwriting the
# file.
shopt -s histappend 2>/dev/null || true

# if readline is being used, a user is given the opportunity to re-edit
# a failed history substitution.
shopt -u histreedit 2>/dev/null || true

# if readline is being used, the results of history substitution are
# not immediately passed to the shell parser.  Instead, the resulting
# line is loaded into the readline editing buffer, allowing further
# modification.
shopt -u histverify 2>/dev/null || true

# if readline is being used, bash will attempt to perform hostname
# completion when a word containing a @ is being completed (see
# Completing under READLINE above).  This is enabled by default.
shopt -s hostcomplete 2>/dev/null || true

# will send SIGHUP to all jobs when an interactive login shell exits.
shopt -u huponexit 2>/dev/null || true

# allow a word beginning with # to cause that word and all remaining
# characters on that line to be ignored in an interactive shell (see
# COMMENTS above).  This option is enabled by default.
shopt -s interactive_comments 2>/dev/null || true

# if job control is not active, the shell runs the last command of a
# pipeline not executed in the background in the current shell
# environment.
shopt -u lastpipe 2>/dev/null || true

# if the cmdhist option is enabled, multi-line commands are saved to
# the history with embedded newlines rather than using semicolon
# separators where possible.
shopt -u lithist 2>/dev/null || true

# The shell sets this option if it is started as a login shell (see
# INVOCATION above).  The value may not be changed.
shopt -u login_shell 2>/dev/null || true

# if a file that bash is checking for mail has been accessed since the
# last time it was checked, the message `The mail in mailfile has been
# read' is displayed.
shopt -u mailwarn 2>/dev/null || true

# if readline is being used, bash will not attempt to search the PATH
# for possible completions when completion is attempted on an empty
# line.
shopt -u no_empty_cmd_completion 2>/dev/null || true

# matches filenames in a case-insensitive fashion when performing
# pathname expansion (see Pathname Expansion above).
shopt -u nocaseglob 2>/dev/null || true

# matches patterns in a case-insensitive fashion when performing
# matching while executing case or [[ conditional commands.
shopt -u nocasematch 2>/dev/null || true

# allows patterns which match no files (see Pathname Expansion above)
# to expand to a null string, rather than themselves.
shopt -u nullglob 2>/dev/null || true

# the programmable completion facilities (see Programmable Completion
# above) are enabled.  This option is enabled by default.
shopt -s progcomp 2>/dev/null || true

# prompt strings undergo parameter expansion, command substitution,
# arithmetic expansion, and quote removal after being expanded as
# described in PROMPTING above.  This option is enabled by default.
shopt -s promptvars 2>/dev/null || true

# The shell sets this option if it is started in restricted mode (see
# RESTRICTED SHELL below).  The value may not be changed.  This is not
# reset when the startup files are executed, allowing the startup files
# to discover whether or not a shell is restricted.
shopt -u restricted_shell 2>/dev/null || true

# the shift builtin prints an error message when the shift count
# exceeds the number of positional parameters.
shopt -u shift_verbose 2>/dev/null || true

# the source (.) builtin uses the value of PATH to find the directory
# containing the file supplied as an argument.  This option is enabled
# by default.
shopt -s sourcepath 2>/dev/null || true

# the echo builtin expands backslash-escape sequences by default.
shopt -u xpg_echo 2>/dev/null || true
