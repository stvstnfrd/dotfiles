#!/bin/sh
# This is just a sample implementation of a slightly less primitive
# interface than xinit. It looks for user .xinitrc and .xserverrc
# files, then system xinitrc and xserverrc files, else lets xinit choose
# its default. The system xinitrc should probably do things like check
# for .Xresources files and merge them in, start up a window manager,
# and pop a clock and several xterms.
#
# Site administrators are STRONGLY urged to write nicer versions.

unset DBUS_SESSION_BUS_ADDRESS
unset SESSION_MANAGER
userclientrc=$HOME/.config/x11/client
sysclientrc=/etc/X11/xinit/xinitrc
userserverrc=$HOME/.config/x11/server
sysserverrc=/etc/X11/xinit/xserverrc
defaultclient=default
defaultserver=/usr/bin/X
defaultserverargs=""
defaultdisplay=""
clientargs=""
serverargs=""
vtarg=""
enable_xauth=1

detect_unused_display() {
    d=0
    while true
    do
        if [ -e "/tmp/.X${d}-lock" ] || [ -S "/tmp/.X11-unix/X${d}" ]
        then
            d=$(expr "${d}" + 1)
        else
            break
        fi
    done
    echo ":${d}"
    unset d
}

teardown() {
    enable_xauth=${1}
    xserverauthfile=${2}
    shift; shift;
    if [ -n "${enable_xauth}" ]
    then
        if [ -n "${*}" ]
        then
            # shellcheck disable=SC2086
            xauth remove "${@}"
        fi
        if [ -n "${xserverauthfile}" ]
        then
            rm -f "${xserverauthfile}"
        fi
    fi
    if command -v deallocvt > /dev/null 2>&1
    then
        deallocvt
    fi
}

parse_args() {
    whoseargs="client"
    clientargs=''
    serverargs=''
    while [ -n "${1}" ]
    do
        case "${1}" in
            --)
                whoseargs='server'
            ;;
            *)
                if [ "${whoseargs}" = 'client' ]
                then
                    clientargs="${clientargs} ${1}"
                else
                    # display must be the FIRST server argument
                    if [ -z "${serverargs}" ] && \
                            expr "${1}" : ':[0-9][0-9]*$' > /dev/null 2>&1
                    then
                        display="${1}"
                    else
                        serverargs="${serverargs} ${1}"
                    fi
                fi
            ;;
        esac
        shift
    done
    printf '%s\n%s\n%s\n%s\n%s\n' "${client:- }" "${clientargs:- }" "${server:- }" "${serverargs:- }" "${display:- }"
}

process_args() {
    read -r client
    read -r clientargs
    read -r server
    read -r serverargs
    read -r display
    clientargs=$(echo "${clientargs}" | sed 's/^ *//')
    serverargs=$(echo "${serverargs}" | sed 's/^ *//')
    defaultclientargs=default
    defaultserver=/usr/bin/X
    defaultserverargs=''
    sysclientrc=/etc/X11/xinit/xinitrc
    sysserverrc=/etc/X11/xinit/xserverrc
    userclientrc=${XINPUTRC:-${XDG_CONFIG_HOME:-${HOME}/.config}/x11/client}
    userserverrc=${XSERVERRC:-${XDG_CONFIG_HOME:-${HOME}/.config}/x11/server}

    if [ -f "${userclientrc}" ]; then
        client=${userclientrc}
    elif [ -f "${sysclientrc}" ]; then
        client=${sysclientrc}
    else
        client=
    fi
    if [ -f "${userserverrc}" ]
    then
        server=${userserverrc}
    elif [ -f "${sysserverrc}" ]
    then
        server=${sysserverrc}
    else
        server=${defaultserver}
    fi
    if [ -z "${clientargs}" ]
    then
        clientargs=${defaultclientargs}
    fi
    if [ -z "${serverargs}" ]
    then
        serverargs=${defaultserverargs}
    fi

    # When starting the defaultserver start X on the current tty to avoid
    # the startx session being seen as inactive:
    # "https://bugzilla.redhat.com/show_bug.cgi?id=806491"
    tty=$(tty)
    vtarg=''
    if expr "$tty" : '/dev/tty[0-9][0-9]*$' > /dev/null
    then
        tty_num=$(echo "${tty}" | grep -oE '[0-9]+$')
        vtarg="vt${tty_num} -keeptty"
    fi

    # if no vt is specified add vtarg (which may be empty)
    have_vtarg="no"
    for i in ${serverargs}; do
        if expr "$i" : 'vt[0-9][0-9]*$' > /dev/null; then
            have_vtarg="yes"
        fi
    done
    if [ "${have_vtarg}" = "no" ]; then
        serverargs="${serverargs} ${vtarg}"
    fi

    # if no display, use default
    if [ -z "${display}" ]
    then
        display=$(detect_unused_display)
    fi

    printf '%s\n%s\n%s\n%s\n%s\n' "${client}" "${clientargs:- }" "${server}" "${serverargs:- }" "${display:- }"
}

enable_xauth() {
    read -r client
    read -r clientargs
    read -r server
    read -r serverargs
    read -r display

    if [ x"${XAUTHORITY}" = x ]; then
        XAUTHORITY=${HOME}/.Xauthority
        export XAUTHORITY
    fi

    removelist=

    # set up default Xauth info for this machine

    # check for GNU hostname
    if hostname --version > /dev/null 2>&1; then
        if hostname --version 2>&1 | grep -q GNU
        then
            hostname=$(hostname -f)
        fi
    fi

    if [ -z "$hostname" ]; then
        hostname=$(hostname)
    fi

    authdisplay=${display:-:0}

    mcookie=$(/usr/bin/mcookie)

    if test x"${mcookie}" = x; then
        echo "Couldn't create cookie"
        exit 1
    fi
    dummy=0

    # create a file with auth information for the server. ':0' is a dummy.
    xserverauthfile=$(mktemp --tmpdir serverauth.XXXXXXXXXX)
    # shellcheck disable=SC2064
    trap "rm -f '${xserverauthfile}'" HUP INT QUIT ILL TRAP BUS TERM
    xauth -q -f "${xserverauthfile}" << EOF
add :${dummy} . ${mcookie}
EOF

    serverargs=${serverargs}" -auth "${xserverauthfile}

    # now add the same credentials to the client authority file
    # if '${displayname}' already exists do not overwrite it as another
    # server may need it. Add them to the '${xserverauthfile}' instead.
    for displayname in ${authdisplay} ${hostname}${authdisplay}; do
        authcookie=$(
            xauth list "${displayname}" \
            | sed -n "s/.*${displayname}[[:space:]*].*[[:space:]*]//p"
        ) 2>/dev/null;
        if [ -z "${authcookie}" ] ; then
            xauth -q << EOF
add ${displayname} . ${mcookie}
EOF
            removelist="${displayname} ${removelist}"
        else
            dummy=$(expr "${dummy}" + 1)
            xauth -q -f "${xserverauthfile}" << EOF
add :${dummy} . ${authcookie}
EOF
        fi
    done
    printf '%s\n%s\n%s\n%s\n%s\n' "${client}" "${clientargs:- }" "${server}" "${serverargs:- }" "${display:- }"
}

main() {
    unset DBUS_SESSION_BUS_ADDRESS
    unset SESSION_MANAGER
    enable_xauth='true'
    if [ -n "${enable_xauth}" ]
    then
        args=$(parse_args "${@}" | process_args | enable_xauth)
    else
        args=$(parse_args "${@}" | process_args)
    fi
    client=$(printf '%s' "${args}" | head -n 1 | tail -n 1)
    clientargs=$(printf '%s' "${args}" | head -n 2 | tail -n 1)
    server=$(printf '%s' "${args}" | head -n 3 | tail -n 1)
    serverargs=$(printf '%s' "${args}" | head -n 4 | tail -n 1)
    display=$(printf '%s' "${args}" | head -n 5 | tail -n 1)
    # shellcheck disable=SC2086
    echo xinit "${client}" ${clientargs} -- "${server}" ${display} ${serverargs}
    exit 1
    retval=${?}
    # shellcheck disable=SC2086
    teardown "${enable_xauth}" "${xserverauthfile}" ${removelist}
    exit ${retval}
}

main "${@}"
