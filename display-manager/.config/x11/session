#!/bin/sh
#h NAME:
#h 	x11/session
#h
#h SYNOPSIS:
#h 	x11/session [executable [arguments ...]]
#h
#h DESCRIPTION:
#h 	An XDG-compliant Xsession replacement.
#h
#h 	See `man Xsession` for a complete overview.
#h
#h EXAMPLES:
#h 	. "${XDG_CONFIG_HOME}/x11/session"
#h
#h OVERVIEW:
#h 	This is a near-copy of /etc/X11/Xsession.
#h 	Notable differences include:
#h 		XDG Compliance
#h
#h 		${USERXSESSIONRC} ${ALTUSERXSESSION} ${USRRESOURCES}
#h 		are loaded from in ${XDG_CONFIG_HOME}/x11/.
#h
#h 		ERRFILE is saved in ${XDG_CACHE_HOME}.
#h
#h 		General code cleanup and refactoring.
#h
#h OPTIONS:
#h
#h 	-h, --help
#h 		Print this message and exit.
#h
#h 	-m, --man
#h 		View this message in a PAGER and exit.
#h
#h 	executable
#h 		This is the script to be exec'ed after setup
#h
#h 	arguments ...
#h 		These options are passed to the executable script.
#h
#h ENVIRONMENT:
#h 	The following environment variables affect the execution of Xsession.d/*:
#h
#h 		USRRESOURCES=${HOME}/.config/x11/resources
#h
#h 		USERXSESSION=${1}
#h
#h 		USERXSESSIONRC=${HOME}/.config/x11/sessionrc
#h
#h 		ALTUSERXSESSION=${HOME}/.config/x11/SESSION
#h
#h 		ERRFILE=$HOME/.cache/xsession-errors
#h
#h FILES:
#h 	OUTPUT
#h 		${XDG_CACHE_HOME}/xsession-errors
#h 			is where standard output and standard error for Xsession script and
#h 			all X client processes are directed by default.
#h
#h 		${TMPDIR}/filename
#h 			is where the X session error file is placed if $HOME/.xsession-errors cannot
#h 			be opened. For security reasons, the exact filename is randomly generated by
#h 			tempfile(1).
#h
#h 	INPUT
#h 		${XDG_CONFIG_HOME}/x11/resources
#h 			contains X resources specific to the invoking user's environment.
#h 			The settings are loaded with xrdb -merge. Note that
#h 			$HOME/.Xdefaults is a relic from X Version 10 (and X11R1) days,
#h 			before app-defaults files were implemented. It has been deprecated
#h 			for over ten years at the time of this writing. .Xresources
#h 			should be used instead.
#h
#h 		${XDG_CONFIG_HOME}/x11/session
#h 			is a sequence of commands invoking X clients (or a session manager
#h 			such as xsm(1)). See the manual page for xinit for tips on writing
#h 			an .xsession file.
#h
#h SEE ALSO:
#h 	Xsession(5)
#h
#h HISTORY:
#h 	stvstnfrd, 2021
#h
#h BUGS:
#h 	https://github.com/stvstnfrd/dotfiles/issues
#h
#h USAGE:
#h 	This is expected to be sourced from an XINITRC file.
#h
#h 		. "${XDG_CONFIG_HOME}/x11/session"
#h
#h VERSION:
#h 	0.0
set -e
while getopts ":hm" option; do case ${option} in
    h) grep '^#h' "${0}" | sed 's/^#h \?//g'; exit;;
    m) "${0}" --help | ${PAGER:-less}; exit;;
    *) ;;
esac; done

PROGNAME=Xsession

message () {
  # pretty-print messages of arbitrary length; use xmessage if it
  # is available and $DISPLAY is set
  MESSAGE="$PROGNAME: $*"
  echo "$MESSAGE" | fold -s -w ${COLUMNS:-80} >&2
  if [ -n "$DISPLAY" ] && which xmessage > /dev/null 2>&1; then
    echo "$MESSAGE" | fold -s -w ${COLUMNS:-80} | xmessage -center -file -
  fi
}

message_nonl () {
  # pretty-print messages of arbitrary length (no trailing newline); use
  # xmessage if it is available and $DISPLAY is set
  MESSAGE="$PROGNAME: $*"
  printf '%s' "${MESSAGE}" | fold -s -w ${COLUMNS:-80} >&2;
  if [ -n "$DISPLAY" ] && which xmessage > /dev/null 2>&1; then
    printf '%s' "${MESSAGE}" | fold -s -w ${COLUMNS:-80} | xmessage -center -file -
  fi
}

errormsg () {
  # exit script with error
  message "$*"
  exit 1
}

internal_errormsg () {
  # exit script with error; essentially a "THIS SHOULD NEVER HAPPEN" message
  # One big call to message() for the sake of xmessage; if we had two then
  # the user would have dismissed the error we want reported before seeing the
  # request to report it.
  errormsg "$*" \
           "Please report the installed version of the \"x11-common\"" \
           "package and the complete text of this error message to" \
           "<debian-x@lists.debian.org>."
}

# initialize variables for use by all session scripts
# shellcheck disable=SC2034
OPTIONFILE=/etc/X11/Xsession.options
# shellcheck disable=SC2034
SYSRESOURCES=/etc/X11/Xresources
# shellcheck disable=SC2034
USRRESOURCES=${HOME}/.config/x11/resources
SYSSESSIONDIR=/etc/X11/Xsession.d
# shellcheck disable=SC2034
USERXSESSION=
# shellcheck disable=SC2034
USERXSESSIONRC=${HOME}/.config/x11/sessionrc
# shellcheck disable=SC2034
ALTUSERXSESSION=${HOME}/.config/x11/SESSION
ERRFILE=$HOME/.cache/xsession-errors

if [ -n "${1}" ]
then
    if command -v "${1}" >/dev/null 2>&1
    then
        # shellcheck disable=SC2034
        USERXSESSION="${1}"
    fi
fi

# attempt to create an error file; abort if we cannot
if (umask 077 && touch "$ERRFILE") 2> /dev/null && [ -w "$ERRFILE" ] &&
  [ ! -L "$ERRFILE" ]; then
  chmod 600 "$ERRFILE"
elif ERRFILE=$(mktemp 2> /dev/null); then
  if ! ln -sf "$ERRFILE" "${TMPDIR:=/tmp}/xsession-$USER"; then
    message "warning: unable to symlink \"$TMPDIR/xsession-$USER\" to" \
             "\"$ERRFILE\"; look for session log/errors in" \
             "\"$TMPDIR/xsession-$USER\"."
  fi
else
  errormsg "unable to create X session log/error file; aborting."
fi

# truncate ERRFILE if it is too big to avoid disk usage DoS
if [ "$(stat -c%s "${ERRFILE}")" -gt 500000 ]; then
  T=$(mktemp -p "${HOME}")
  (tail -c 500000 "${ERRFILE}" > "${T}" && mv -f "${T}" "${ERRFILE}" ) || rm -f "${T}"
fi

exec >>"$ERRFILE" 2>&1

echo "$PROGNAME: X session started for $LOGNAME at $(date)"

# sanity check; is our session script directory present?
if [ ! -d "$SYSSESSIONDIR" ]; then
  errormsg "no \"$SYSSESSIONDIR\" directory found; aborting."
fi

# Attempt to create a file of non-zero length in /tmp; a full filesystem can
# cause mysterious X session failures.  We do not use touch, :, or test -w
# because they won't actually create a file with contents.  We also let standard
# error from mktemp and echo go to the error file to aid the user in
# determining what went wrong.
WRITE_TEST=$(mktemp)
if ! echo "*" >>"$WRITE_TEST"; then
  message "warning: unable to write to ${WRITE_TEST%/*}; X session may exit" \
          "with an error"
fi
rm -f "$WRITE_TEST"

# use run-parts to source every file in the session directory; we source
# instead of executing so that the variables and functions defined above
# are available to the scripts, and so that they can pass variables to each
# other
SESSIONFILES=$(run-parts --list $SYSSESSIONDIR)
if [ -n "$SESSIONFILES" ]; then
  set +e
  for SESSIONFILE in $SESSIONFILES; do
    # shellcheck disable=SC1090
    . "${SESSIONFILE}"
  done
  set -e
fi

exit 0
# vim:set ai et sts=2 sw=2 tw=80:
